// Generated by CoffeeScript 1.9.1
(function() {
  var _, v;

  _ = require('underscore');

  v = {
    validateDocUpdate: function(validationFns, getDocType, shouldSkipValidationForUser) {
      shouldSkipValidationForUser || (shouldSkipValidationForUser = function() {
        return false;
      });
      return function(newDoc, oldDoc, actor) {
        var actions, docType, newAuditEntries;
        docType = getDocType(oldDoc || newDoc);
        actions = validationFns[docType];
        newAuditEntries = v.getNewAuditEntries(newDoc, oldDoc);
        if (shouldSkipValidationForUser(actor) || !actions || !newAuditEntries.length) {
          return;
        }
        return v.validateAuditEntries(actions, newAuditEntries, actor, oldDoc, newDoc);
      };
    },
    getNewAuditEntries: function(newDoc, oldDoc) {
      var newEntries, newLog, oldEntries, oldLog;
      newLog = newDoc.audit || [];
      oldLog = oldDoc ? oldDoc.audit : [];
      newEntries = newLog.slice(oldLog.length);
      if (!newEntries.length) {
        return newEntries;
      }
      oldEntries = newLog.slice(0, oldLog.length);
      if (!_.isEqual(oldLog, oldEntries)) {
        throw {
          code: 403,
          body: 'Entries are immutable. original entries: ' + JSON.stringify(oldLog) + '; modified entries: ' + JSON.stringify(oldEntries) + '.'
        };
      }
      return newEntries;
    },
    validateAuditEntries: function(actions, newAuditEntries, actor, oldDoc, newDoc) {
      return newAuditEntries.forEach(function(entry) {
        return v.validateAuditEntry(actions, entry, actor, oldDoc, newDoc);
      });
    },
    validateAuditEntry: function(actions, entry, actor, oldDoc, newDoc) {
      var authorized, e;
      if (entry.u !== actor.name) {
        throw {
          code: 403,
          body: 'User performing action (' + entry.u + ') does not match logged in user (' + actor.name + ').'
        };
      }
      if (!(entry.a in actions)) {
        throw {
          code: 403,
          body: 'Invalid action: ' + entry.a + '.'
        };
      }
      try {
        return authorized = actions[entry.a](entry, actor, oldDoc, newDoc) || false;
      } catch (_error) {
        e = _error;
        if (e.state === 'unauthorized') {
          throw {
            code: 401,
            body: e.err
          };
        } else {
          throw {
            code: 403,
            body: e.err
          };
        }
      }
    }
  };

  module.exports = v;

}).call(this);
